# Kafka双证书SSL Secret配置
# 支持分离的server和client认证证书

apiVersion: v1
kind: Secret
metadata:
  name: kafka-ssl-certs
  namespace: confluent-kafka
  labels:
    app: kafka
    component: ssl-certs
type: Opaque
data:
  # Server认证证书（用于Kafka broker身份验证）
  kafka.server.keystore.jks: <BASE64_ENCODED_SERVER_KEYSTORE>
  server.keystore.password: <BASE64_ENCODED_SERVER_KEYSTORE_PASSWORD>
  server.key.password: <BASE64_ENCODED_SERVER_KEY_PASSWORD>
  
  # Client认证证书（用于客户端身份验证）
  kafka.client.keystore.jks: <BASE64_ENCODED_CLIENT_KEYSTORE>
  client.keystore.password: <BASE64_ENCODED_CLIENT_KEYSTORE_PASSWORD>
  client.key.password: <BASE64_ENCODED_CLIENT_KEY_PASSWORD>
  
  # 信任库（包含CA证书，server和client共用）
  kafka.truststore.jks: <BASE64_ENCODED_TRUSTSTORE>
  truststore.password: <BASE64_ENCODED_TRUSTSTORE_PASSWORD>

---
# 创建Secret的脚本示例
# 
# # 1. 编码server keystore
# kubectl create secret generic kafka-ssl-certs \
#   --from-file=kafka.server.keystore.jks=path/to/your/server-keystore.jks \
#   --from-file=kafka.client.keystore.jks=path/to/your/client-keystore.jks \
#   --from-file=kafka.truststore.jks=path/to/your/truststore.jks \
#   --from-literal=server.keystore.password=your-server-keystore-password \
#   --from-literal=server.key.password=your-server-key-password \
#   --from-literal=client.keystore.password=your-client-keystore-password \
#   --from-literal=client.key.password=your-client-key-password \
#   --from-literal=truststore.password=your-truststore-password \
#   --namespace=confluent-kafka \
#   --dry-run=client -o yaml > kafka-ssl-secrets-dual.yaml
#
# # 2. 应用Secret
# kubectl apply -f kafka-ssl-secrets-dual.yaml 
